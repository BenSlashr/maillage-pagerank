{% extends "layout.html" %}

{% block title %}Google Search Console - SEO Internal Linking Tool{% endblock %}

{% block content %}
<div class="container" x-data="gscApp" x-init="init()">
    <div class="row mb-4">
        <div class="col-12">
            <div class="card shadow-sm">
                <div class="card-body">
                    <h2 class="card-title">
                        <i class="bi bi-google me-2"></i>Google Search Console
                    </h2>
                    <p class="card-text">Importez directement vos données de Search Console pour analyser votre maillage interne.</p>
                    
                    <div x-show="!authenticated && hasCredentials" class="text-center my-4">
                        <p>Connectez-vous à votre compte Google pour accéder à vos données Search Console.</p>
                        <button @click="authenticate" class="btn btn-primary">
                            <i class="bi bi-google me-2"></i>Se connecter avec Google
                        </button>
                    </div>
                    
                    <div x-show="!hasCredentials" class="text-center my-4">
                        <div class="alert alert-warning">
                            <i class="bi bi-exclamation-triangle-fill me-2"></i>Vous devez d'abord configurer vos identifiants Google pour utiliser cette fonctionnalité.
                        </div>
                        <a href="/google-config" class="btn btn-primary">
                            <i class="bi bi-gear me-2"></i>Configurer les identifiants Google
                        </a>
                    </div>
                    
                    <div x-show="authenticated" class="mt-4">
                        <div class="alert alert-success" role="alert">
                            <i class="bi bi-check-circle-fill me-2"></i>Vous êtes connecté à Google Search Console
                            <a href="/api/google/logout" class="btn btn-sm btn-outline-secondary float-end">
                                <i class="bi bi-box-arrow-right me-1"></i>Se déconnecter
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div x-show="authenticated" class="row mb-4">
        <div class="col-12">
            <div class="card shadow-sm">
                <div class="card-body">
                    <h3 class="card-title">Sélection des données</h3>
                    
                    <div class="mb-3">
                        <label for="siteSelect" class="form-label">Propriété Search Console</label>
                        <select id="siteSelect" class="form-select" x-model="selectedSite">
                            <option value="">Sélectionnez une propriété</option>
                            <template x-for="site in sites" :key="site.url">
                                <option :value="site.url" x-text="site.name"></option>
                            </template>
                        </select>
                    </div>
                    
                    <div class="row">
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="startDate" class="form-label">Date de début</label>
                                <input type="date" id="startDate" class="form-control" x-model="startDate">
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="endDate" class="form-label">Date de fin</label>
                                <input type="date" id="endDate" class="form-control" x-model="endDate">
                            </div>
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Dimensions</label>
                        <div class="alert alert-info">
                            <i class="bi bi-info-circle me-2"></i>Les dimensions <strong>Page (URL)</strong> et <strong>Requête (mot-clé)</strong> sont automatiquement sélectionnées pour optimiser les suggestions d'ancres.
                        </div>
                        <input type="hidden" value="page" x-model="dimensions">
                        <input type="hidden" value="query" x-model="dimensions">
                    </div>
                    
                    <div class="d-flex justify-content-between flex-wrap gap-2">
                        <button @click="fetchData" class="btn btn-primary" :disabled="!canFetchData || isLoading">
                            <span x-show="isLoading" class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                            <i x-show="!isLoading" class="bi bi-download me-2"></i>
                            Récupérer les données
                        </button>
                        
                        <button @click="exportToFile" class="btn btn-outline-primary" :disabled="!hasData || isExporting">
                            <span x-show="isExporting" class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                            <i x-show="!isExporting" class="bi bi-file-earmark-arrow-down me-2"></i>
                            Exporter en CSV
                        </button>
                        
                        <button @click="sendToAnalysis" class="btn btn-success" :disabled="!hasData || isSendingToAnalysis">
                            <span x-show="isSendingToAnalysis" class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                            <i x-show="!isSendingToAnalysis" class="bi bi-arrow-right-circle me-2"></i>
                            Envoyer vers l'analyse
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div x-show="hasData" class="row">
        <div class="col-12">
            <div class="card shadow-sm">
                <div class="card-body">
                    <h3 class="card-title">Résultats</h3>
                    
                    <div class="mb-3">
                        <input type="text" class="form-control" placeholder="Rechercher..." x-model="searchQuery">
                    </div>
                    
                    <div class="table-responsive">
                        <table class="table table-striped table-hover">
                            <thead>
                                <tr>
                                    <template x-for="(column, index) in tableColumns" :key="index">
                                        <th x-text="column"></th>
                                    </template>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="(row, rowIndex) in filteredData" :key="rowIndex">
                                    <tr>
                                        <template x-for="(column, colIndex) in tableColumns" :key="colIndex">
                                            <td x-text="row[column]"></td>
                                        </template>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                    
                    <div x-show="filteredData.length === 0 && searchQuery" class="alert alert-info">
                        Aucun résultat ne correspond à votre recherche.
                    </div>
                    
                    <div x-show="filteredData.length === 0 && !searchQuery" class="alert alert-warning">
                        Aucune donnée disponible pour les critères sélectionnés.
                    </div>
                    
                    <div class="mt-3 text-end">
                        <span class="text-muted">
                            <template x-if="filteredData.length !== analyticsData.length">
                                Affichage de <strong x-text="filteredData.length"></strong> sur <strong x-text="analyticsData.length"></strong> résultats
                            </template>
                            <template x-if="filteredData.length === analyticsData.length">
                                <strong x-text="analyticsData.length"></strong> résultats
                            </template>
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div x-show="exportSuccess" class="row mt-4">
        <div class="col-12">
            <div class="alert alert-success alert-dismissible fade show" role="alert">
                <i class="bi bi-check-circle-fill me-2"></i>
                Export réussi ! <a :href="'/api/download/' + exportFilename" class="alert-link">Télécharger le fichier</a>
                <button type="button" class="btn-close" @click="exportSuccess = false" aria-label="Close"></button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('gscApp', () => ({
            authenticated: false,
            hasCredentials: false,
            sites: [],
            selectedSite: '',
            startDate: '',
            endDate: '',
            dimensions: ['page', 'query'],
            analyticsData: [],
            tableColumns: [],
            searchQuery: '',
            isLoading: false,
            isExporting: false,
            isSendingToAnalysis: false,
            exportSuccess: false,
            exportFilename: '',
            
            init() {
                // Initialiser les dates par défaut (30 derniers jours)
                const today = new Date();
                const thirtyDaysAgo = new Date();
                thirtyDaysAgo.setDate(today.getDate() - 30);
                
                this.endDate = this.formatDate(today);
                this.startDate = this.formatDate(thirtyDaysAgo);
                
                // Vérifier si les identifiants sont configurés
                this.checkCredentials().then(() => {
                    // Vérifier le statut d'authentification
                    this.checkAuthStatus();
                    
                    // Vérifier si nous venons d'être authentifiés (paramètre dans l'URL)
                    const urlParams = new URLSearchParams(window.location.search);
                    if (urlParams.get('auth') === 'success') {
                        // Rafraîchir la page sans le paramètre pour éviter les problèmes de cache
                        setTimeout(() => {
                            window.location.href = '/gsc';
                        }, 500);
                    }
                });
            },
            
            async checkCredentials() {
                try {
                    const response = await fetch(`${basePath}/api/google/status-credentials`);
                    const data = await response.json();
                    this.hasCredentials = data.has_credentials;
                } catch (error) {
                    console.error('Erreur lors de la vérification des identifiants:', error);
                    this.hasCredentials = false;
                }
            },
            
            formatDate(date) {
                return date.toISOString().split('T')[0];
            },
            
            async checkAuthStatus() {
                try {
                    const response = await fetch(`${basePath}/api/google/status`);
                    const data = await response.json();
                    console.log('Statut d\'authentification:', data);
                    this.authenticated = data.authenticated;
                    
                    if (this.authenticated) {
                        this.loadSites();
                    }
                } catch (error) {
                    console.error('Erreur lors de la vérification du statut:', error);
                    this.authenticated = false;
                }
            },
            
            async authenticate() {
                try {
                    console.log('Début de l\'authentification...');
                    const response = await fetch(`${basePath}/api/google/auth`);
                    const data = await response.json();
                    
                    console.log('Réponse de l\'API auth:', data);
                    
                    // Vérifier si la réponse contient une erreur
                    if (data.detail) {
                        throw new Error(data.detail);
                    }
                    
                    // Vérifier si l'URL d'authentification est présente
                    if (!data.auth_url) {
                        throw new Error('URL d\'authentification manquante dans la réponse');
                    }
                    
                    console.log('Redirection vers l\'URL d\'authentification Google:', data.auth_url);
                    
                    // Rediriger vers l'URL d'authentification Google
                    window.location.href = data.auth_url;
                } catch (error) {
                    console.error('Erreur lors de l\'authentification:', error);
                    alert('Erreur lors de l\'authentification: ' + error.message);
                }
            },
            
            async loadSites() {
                try {
                    const response = await fetch(`${basePath}/api/google/sites`);
                    const data = await response.json();
                    
                    this.sites = data.sites;
                    this.authenticated = data.authenticated;
                } catch (error) {
                    console.error('Erreur lors du chargement des sites:', error);
                    alert('Erreur lors du chargement des sites. Veuillez réessayer.');
                }
            },
            
            async fetchData() {
                if (!this.canFetchData) return;
                
                this.isLoading = true;
                
                try {
                    // S'assurer que page et query sont toujours sélectionnés
                    if (!this.dimensions.includes('page')) this.dimensions.push('page');
                    if (!this.dimensions.includes('query')) this.dimensions.push('query');
                    
                    const response = await fetch(`${basePath}/api/google/analytics`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            site_url: this.selectedSite,
                            start_date: this.startDate,
                            end_date: this.endDate,
                            dimensions: this.dimensions
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || 'Erreur lors de la récupération des données');
                    }
                    
                    const data = await response.json();
                    this.analyticsData = data.data;
                    
                    // Déterminer les colonnes du tableau
                    if (this.analyticsData.length > 0) {
                        this.tableColumns = Object.keys(this.analyticsData[0]);
                    }
                } catch (error) {
                    console.error('Erreur:', error);
                    alert('Erreur: ' + error.message);
                } finally {
                    this.isLoading = false;
                }
            },
            
            async exportToFile() {
                if (!this.hasData) return;
                
                this.isExporting = true;
                
                try {
                    const response = await fetch(`${basePath}/api/google/export-to-file`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            site_url: this.selectedSite,
                            start_date: this.startDate,
                            end_date: this.endDate,
                            dimensions: this.dimensions
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || 'Erreur lors de l\'export des données');
                    }
                    
                    const data = await response.json();
                    this.exportSuccess = true;
                    this.exportFilename = data.filename;
                } catch (error) {
                    console.error('Erreur:', error);
                    alert('Erreur: ' + error.message);
                } finally {
                    this.isExporting = false;
                }
            },
            
            async sendToAnalysis() {
                if (!this.hasData) return;
                
                this.isSendingToAnalysis = true;
                
                try {
                    // Vérifier que les colonnes query et page sont présentes
                    if (!this.tableColumns.includes('query') || !this.tableColumns.includes('page')) {
                        throw new Error('Les colonnes "query" et "page" sont requises pour l\'analyse des ancres');
                    }
                    
                    // Extraire uniquement les colonnes query et page pour l'analyse dans le bon ordre
                    // L'ordre query/page est important pour avoir plusieurs requêtes par page
                    const requiredColumns = ['query', 'page'];
                    
                    // Préparer les données au format attendu par l'analyse
                    const formattedData = this.analyticsData.map(item => {
                        const formattedItem = {};
                        requiredColumns.forEach(col => {
                            // S'assurer que les valeurs ne sont pas nulles ou undefined
                            formattedItem[col] = item[col] || '';
                        });
                        return formattedItem;
                    });
                    
                    // Convertir les données en format CSV
                    const headers = requiredColumns.join(',');
                    const rows = formattedData.map(item => 
                        requiredColumns.map(col => {
                            // S'assurer que les valeurs sont correctement formatées pour le CSV
                            const value = item[col];
                            if (typeof value === 'string') {
                                // Échapper les guillemets doubles en les doublant et entourer de guillemets
                                return `"${value.replace(/"/g, '""')}"`;
                            } else if (value === null || value === undefined) {
                                return '';
                            } else {
                                return value;
                            }
                        }).join(',')
                    );
                    const csvContent = [headers, ...rows].join('\n');
                    
                    // Créer un Blob et un fichier temporaire
                    const blob = new Blob([csvContent], { type: 'text/csv' });
                    const file = new File([blob], 'gsc_data.csv', { type: 'text/csv' });
                    
                    console.log('Fichier CSV généré avec succès:', {
                        colonnes: requiredColumns,
                        nombreLignes: rows.length,
                        taille: blob.size,
                        premieresLignes: rows.slice(0, 3)
                    });
                    
                    // Créer un FormData pour l'upload
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    // Envoyer le fichier au serveur
                    const uploadResponse = await fetch(`${basePath}/api/upload/gsc`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!uploadResponse.ok) {
                        const errorData = await uploadResponse.json();
                        throw new Error(errorData.detail || 'Erreur lors de l\'upload du fichier GSC');
                    }
                    
                    const uploadData = await uploadResponse.json();
                    console.log('Réponse du serveur après upload:', uploadData);
                    
                    // Vérifier quel champ est présent dans la réponse (saved_path ou file_path)
                    const filePath = uploadData.saved_path || uploadData.file_path;
                    
                    if (!filePath) {
                        throw new Error('Chemin du fichier GSC non trouvé dans la réponse du serveur');
                    }
                    
                    // Stocker le chemin du fichier GSC dans localStorage pour le rendre persistant entre les onglets
                    localStorage.setItem('gscFilePath', filePath);
                    
                    // Rediriger vers la page d'analyse avec le fichier GSC préchargé et auto_start=true
                    window.location.href = `/analysis?gsc_file=${filePath}&auto_start=true`;
                    
                } catch (error) {
                    console.error('Erreur:', error);
                    alert('Erreur lors de l\'envoi vers l\'analyse: ' + error.message);
                } finally {
                    this.isSendingToAnalysis = false;
                }
            },
            
            get canFetchData() {
                return this.authenticated && this.selectedSite && this.startDate && this.endDate && this.dimensions.length > 0;
            },
            
            get hasData() {
                return this.analyticsData && this.analyticsData.length > 0;
            },
            
            get filteredData() {
                if (!this.searchQuery) return this.analyticsData;
                
                const query = this.searchQuery.toLowerCase();
                return this.analyticsData.filter(item => {
                    return Object.values(item).some(value => 
                        String(value).toLowerCase().includes(query)
                    );
                });
            }
        }));
    });
</script>
{% endblock %}
